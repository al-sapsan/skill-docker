___
# Отчет о выполнении практической работы по теме: "Виртуализация и контейнеризация"
___
## Подготовительный этап
С учетом выполненной практической работы по теме: [Работа с системой контроля версий Git](https://github.com/al-sapsan/skill-linux/tree/module4) и с целью дальнейшего углубления и практического усвоения полученных знаний, было принято решение, в рамках данной работы, осуществить копию (подобие) полномасштабного проекта с участием привлеченных сотрудников (Collaborators), созданием проекта в GitHub Projects, использованием различных ветвей для отдельных частей проекта, формированием и рассмотрением запросов на слияние изменений (Pull requests) и т.д.

Также, ввиду наличия в сети противоречивой информации об использовании дистрибутивов Ubuntu и Alpine linux для развертывания образов Docker, хотелось бы самому поглубже разобраться с этим вопросом. 

**Учитывая вышесказанное, на подготовительном этапе были выполнены следующие действия:**
1. Созданы и надлежащим образом оформлены аккаунты "привлеченных сотрудников", которые были поименованы как: [git-tester1](https://github.com/git-tester1) и [git-tester2](https://github.com/git-tester2).
2. Направлены приглашения на сотрудничество с помошью соответствующего интерфейса GitHub, которые были успешно приняты и подтверждены :-)
3. Создан данный репозиторий `skill-docker` для размещения проекта.
4. С помощью GitHub Projects создан [проект](https://github.com/users/al-sapsan/projects/2), в котором всем сотрудникам были даны задания.
5. В соответствии с полученными заданиями, в репозитории `skill-docker` были созданы следующие ветви:
  - `main` - ветвь репозитория для размещения окончательного варианта выполненного проекта;
  - `dev` - ветвь по умолчанию, созданная для размещения рабочих вариантов проекта;
  - `docker-container` - ветвь, созданная [git-tester1](https://github.com/git-tester1) для размещения своей части проекта;
  - `python-code` - ветвь, созданная [git-tester2](https://github.com/git-tester2) для размещения своей части проекта.
___
## Разработка программы на Python

### 1. Общее описание выполненных действий
В целях простоты и наглядности выполнения задания, был выбран и реализован код, который преобразует любое изображение в [ASCII-арт](https://ru.wikipedia.org/wiki/ASCII-графика), сохраняя его пропорции и используя символы для представления яркости каждого пикселя. По условиям проекта данный код был создан сотрудником [git-tester2](https://github.com/git-tester2) в ветви `python-code`. После создания кода и его утверждения, [git-tester2](https://github.com/git-tester2) сформировала запрос на слияние, который был одобрен, после чего произведено слияние ветви `python-code` и ветви `dev`. Ветвь `python-code` не удалялась для контроля проделанной работы.

### 2. Разработанный код

```python
from PIL import Image # import the PIL library

# Set the ASCII characters that will be used to create the art
ASCII_CHARS = ["@", "#", "S", "%", "?", "*", "+", ";", ":", ",", "."]

def resize_image(image, new_width=100):
    width, height = image.size
    aspect_ratio = height / width
    new_height = int(new_width * aspect_ratio)
    resized_image = image.resize((new_width, new_height))
    return resized_image

def modify_into_grayscale_image(image):
    return image.convert("L")

# Map each pixel to an ASCII character
def transform_pixels_to_ascii(image):
    pixels = image.getdata()
    ascii_str = ""
    for pixel in pixels:
        ascii_str += ASCII_CHARS[pixel // 25]
    return ascii_str

# Main function
def convert_image_to_ascii(image_path, new_width=100):
    try:
        image = Image.open(image_path)
    except Exception as e:
        print(e)
        return
    # Resize and convert to grayscale
    image = resize_image(image, new_width)
    image = modify_into_grayscale_image(image)
    # Convert pixels to ASCII
    ascii_str = transform_pixels_to_ascii(image)
    # Format an ASCII string for proper display
    img_width = image.width
    ascii_art = ""
    for i in range(0, len(ascii_str), img_width):
        ascii_art += ascii_str[i:i + img_width] + "\n"
    return ascii_art

# Example of use
path = "/app/drone.jpeg"
ascii_art = convert_image_to_ascii(path)
print(ascii_art)

# Saving the obtained result to a file
with open("ascii_image.txt", "w") as f:
    f.write(ascii_art)
```
**Примечание:** комментарии в коде написаны на английском языке не с целью демонстрации его знания, а так как `pylint` в VIMе постоянно ругался на отсутствие комментариев, чем изрядно раздражал создателя кода :-) 

### 3. Описание работы кода

#### 3.1. Импортирование необходимой библиотеки
```python
from PIL import Image 
```
Эта строка импортирует `Image` из модуля `PIL` (Python Imaging Library), который используется для открытия, обработки и сохранения файлов изображений.

#### 3.2. Определение ASCII-символов
```python
ASCII_CHARS = ["@", "#", "S", "%", "?", "*", "+", ";", ":", ",", "."]
```
Этот список содержит символы, которые будут использоваться для представления различных оттенков серого в ASCII-арте. Символы расположены от самых темных (`@`) до самых светлых (`.`).

#### 3.3. Изменение размера изображения
```python
def resize_image(image, new_width=100):
    width, height = image.size
    aspect_ratio = height / width
    new_height = int(new_width * aspect_ratio)
    resized_image = image.resize((new_width, new_height))
    return resized_image
```
- **Цель функции**: Эта функция изменяет размер входного изображения, сохраняя его соотношение сторон.
- **Параметры**: 
  - `image`: Входное изображение, которое нужно изменить.
  - `new_width`: Желаемая ширина измененного изображения (по умолчанию 100 пикселей).
- **Процесс**:
  - Вычисляется соотношение сторон оригинального изображения.
  - Рассчитывается новая высота на основе соотношения сторон и желаемой ширины.
  - Изображение изменяется до новых размеров и возвращается.

#### 3.4. Преобразование в градации серого
```python
def modify_into_grayscale_image(image):
    return image.convert("L")
```
- **Цель функции**: Эта функция преобразует входное изображение в градации серого.
- **Параметры**: 
  - `image`: Входное изображение для преобразования.
- **Процесс**: Используется метод `convert` с режимом `"L"` (яркость) для преобразования изображения в градации серого и возвращается.

#### 3.5. Преобразование пикселей в ASCII-символы
```python
def transform_pixels_to_ascii(image):
    pixels = image.getdata()
    ascii_str = ""
    for pixel in pixels:
        ascii_str += ASCII_CHARS[pixel // 25]
    return ascii_str
```
- **Цель функции**: Эта функция сопоставляет значение яркости каждого пикселя с ASCII-символом.
- **Параметры**: 
  - `image`: Изображение в градациях серого, из которого будут извлекаться данные пикселей.
- **Процесс**:
  - Извлекаются данные пикселей из изображения с помощью метода `getdata()`.
  - Для каждого значения пикселя (от 0 до 255) вычисляется индекс, деля на 25 (так как есть 10 ASCII-символов), и соответствующий символ из `ASCII_CHARS` добавляется к строке.

#### 3.6. Основная функция для преобразования
```python
def convert_image_to_ascii(image_path, new_width=100):
    try:
        image = Image.open(image_path)
    except Exception as e:
        print(e)
        return
    # Resize and convert to grayscale
    image = resize_image(image, new_width)
    image = modify_into_grayscale_image(image)
    # Convert pixels to ASCII
    ascii_str = transform_pixels_to_ascii(image)
    # Format an ASCII string for proper display
    img_width = image.width
    ascii_art = ""
    for i in range(0, len(ascii_str), img_width):
        ascii_art += ascii_str[i:i + img_width] + "\n"
    return ascii_art

```
- **Цель функции**: Это основная функция, которая координирует весь процесс преобразования изображения в ASCII-арт.
- **Параметры**: 
  - `image_path`: Путь к файлу входного изображения.
  - `new_width`: Желаемая ширина для изменения размера (по умолчанию 100).
- **Процесс**:
  - Пытается открыть указанный файл изображения. Если это не удается, выводит сообщение об ошибке и завершает выполнение.
  - Изменяет размер и преобразует открытое изображение в градации серого.
  - Преобразует данные пикселей в строку ASCII.
  - Наконец, форматирует эту строку в строки, которые соответствуют ширине измененного изображения.

#### 3.7. Входные данные
```python
path = "/app/drone.jpeg"
ascii_art = convert_image_to_ascii(path)
print(ascii_art)
```
Этот раздел инициирует функцию `convert_image_to_ascii`, предоставляя путь к изображению (`drone.jpeg`). Данный путь указан в соответствии с размещением файла в образе Docker. Полученный ASCII-арт выводится на консоль.

#### 3.8. Сохранение ASCII-арта в файл
```python
with open("ascii_image.txt", "w") as f:
    f.write(ascii_art)
```
Этот блок сохраняет сгенерированный ASCII-арт в текстовый файл с именем `ascii_image.txt`. 
___
## Создание Dockerfile.

### 1. Общее описание выполненных действий
Как уже было указано выше, в начале работы по созданию образов Docker возникла дилемма: какой из дистрибутивов Linux использовать. По имеющейся информации в сети, наибольшей популярности пользуются:
  - `Debian` - в виду стабильности и обширности репозитория;
  - `Ubuntu` - в виду большей дружелюбности интерфейса по сравнению с `Debian`, при должной стабильности, обновляемости и обширности репозитория;
  - `Alpine linux` - в виду своей минималистичности, безопасности и скорости работы.

И если с распределением сфер использования `Debian` и `Ubuntu` все понятно, то с использованием образов на `Alpine linux` для приложений на `Python` [имеются значительные разногласия](https://habr.com/ru/articles/707858/). Таким образом, в целях подробного изучения особенностей использования `Alpine linux` и `Ubuntu` для развертывания Python-приложений, были выбраны данные два дистрибутива. По условиям проекта данная часть была поручена сотруднику [git-tester1](https://github.com/git-tester1) и создавалась в ветви `docker-container`. После окончания работы и утверждения результатов, [git-tester1](https://github.com/git-tester1) сформировал запрос на слияние, который был одобрен, после чего произведено слияние ветви `docker-container` и ветви `dev`. Ветвь `docker-container` не удалялась для контроля выполненных действий.

### 2. Dockerfile для Alpine-образа
```dockerfile
# Используем базовый образ Alpine Linux с Python 3.12
FROM python:3.12-alpine

# Устанавливаем зависимости системы
RUN apk add --no-cache \
    build-base \
    python3-dev \
    libjpeg-turbo-dev \
    zlib-dev \
    freetype-dev \
    lcms2-dev \
    tiff-dev

# Устанавливаем Python-зависимости
RUN pip install --no-cache-dir --upgrade pip \
    && pip install --no-cache-dir pillow

# Создаем рабочую директорию в контейнере
WORKDIR /app

# Копируем ваш файл программы в контейнер
COPY . /app

# Указываем команду для запуска программы
CMD ["python", "ascii-art.py"]
```

#### Описание Dockerfile для Alpine-образа

- **Базовый образ**
```dockerfile
FROM python:3.12-alpine
```
Эта строка указывает базовый образ для контейнера, которым является `python:3.12-alpine`, содержащий в себе Python 3.12 и Alpine Linux.

- **Установка системных зависимостей**
```dockerfile
RUN apk add --no-cache \
    build-base \
    python3-dev \
    libjpeg-turbo-dev \
    zlib-dev \
    freetype-dev \
    lcms2-dev \
    tiff-dev
```
Здесь команда `RUN` устанавливает несколько системных зависимостей с помощью менеджера пакетов Alpine, `apk`. Опция `--no-cache` предотвращает кэширование индекса пакетов, что помогает уменьшить размер образа. Подробнее об используемых зависимостях можно узнать [на странице Wiki данного репозитория](https://github.com/al-sapsan/skill-docker/wiki/6.-ASCII%E2%80%90art-зависимости).

- **Зависимости Python**
```dockerfile
RUN pip install --no-cache-dir --upgrade pip \
    && pip install --no-cache-dir pillow
```
В этом разделе обновляется `pip` до последней версии и устанавливается библиотека Pillow без кэширования файлов. Опция `--no-cache-dir` используется для уменьшения окончательного размера образа за счет того, что загруженные пакеты не сохраняются в кэше.

- **Рабочая директория**
```dockerfile
WORKDIR /app
```
Инструкция `WORKDIR` устанавливает рабочую директорию `/app` внутри контейнера. Это означает, что все последующие команды будут выполняться в этой директории.

- **Копирование файлов приложения**
```dockerfile
COPY . /app
```
Эта команда копирует все файлы из текущей директории на хост-машине в директорию `/app` в контейнере. В данном случае это - файлы `ascii-art.py` и `drone.jpeg`.

- **Команда для запуска приложения**
```dockerfile
CMD ["python", "ascii-art.py"]
```
Эта строка указывает команду, которая будет выполняться при запуске контейнера из этого образа. 

### 3. Dockerfile для Ubuntu-образа
```dockerfile
# Используем базовый образ Ubuntu 22.04
FROM ubuntu:22.04

# Устанавливаем зависимости системы
RUN apt-get update && apt-get install -y --no-install-recommends \
    python3 \
    python3-pip \
    python3-dev \
    build-essential \
    libjpeg-dev \
    zlib1g-dev \
    libfreetype6-dev \
    liblcms2-dev \
    libtiff-dev \
    libwebp-dev \
    && apt-get clean \
    && rm -rf /var/lib/apt/lists/*

# Устанавливаем Python-зависимости
RUN pip install --no-cache-dir pillow

# Создаем рабочую директорию в контейнере
WORKDIR /app

# Копируем ваш файл программы в контейнер
COPY . /app

# Указываем команду для запуска программы
CMD ["python3", "ascii-art.py"]
```

#### Описание Dockerfile для Ubuntu-образа

- **Базовый образ**
```dockerfile
FROM ubuntu:22.04
```
В данном случае используется базовый образ Ubuntu версии 22.04. 

- **Установка системных зависимостей**
```dockerfile
RUN apt-get update && apt-get install -y --no-install-recommends \
    python3 \
    python3-pip \
    python3-dev \
    build-essential \
    libjpeg-dev \
    zlib1g-dev \
    libfreetype6-dev \
    liblcms2-dev \
    libtiff-dev \
    libwebp-dev \
    && apt-get clean \
    && rm -rf /var/lib/apt/lists/*
```
Здесь команда `RUN` обновляет список пакетов с помощью `apt-get update`, устанавливает необходимые пакеты для работы с `Python`, библиотекой `Pillow` и библиотеки для работы с различными форматами изображений (JPEG, PNG, TIFF и т.д.). После установки пакетов выполняется очистка кэша и удаление временных файлов для уменьшения размера образа. Подробнее об используемых зависимостях можно узнать [на странице Wiki данного репозитория](https://github.com/al-sapsan/skill-docker/wiki/6.-ASCII%E2%80%90art-зависимости).

- **Установка Python-зависимостей**
```dockerfile
RUN pip install --no-cache-dir pillow
```
Здесь непосредственно устанавливается библиотека Pillow, которая используется для обработки изображений. 

- **Создание рабочей директории**
```dockerfile
WORKDIR /app
```
Эта команда создает рабочую директорию `/app` внутри контейнера и устанавливает её как текущую директорию для последующих команд.

- **Копирование файлов программы в контейнер**
```dockerfile
COPY . /app
```
Эта команда копирует все файлы из текущей директории на хост-машине в директорию `/app` в контейнере. В данном случае это - файлы `ascii-art.py` и `drone.jpeg`.

- **Указание команды для запуска программы**
```dockerfile
CMD ["python3", "ascii-art.py"]
```
Эта команда указывает, что при запуске контейнера будет выполнен скрипт `ascii-art.py` с использованием интерпретатора Python 3.

___
## Сборка Docker-образов из созданных Dockerfile

### 1. Описание процесса сборки
Во исполнение задач практической работы и учитывая цели сравнения двух дистрибутивов, сборка образов проводилась на трех ноутбуках:
  - **MacBook Pro модели А1286**, процессор Intel Core i7 2.3GHz, графика Intel HD Graphics 4000 & NVIDIA GeForce GT 650M 512MB GDDR5 memory, память 16GB (2 * 8GB 1600MHz DDR3), c установленной операционной системой **Ubuntu 20.04**;
  - **MacBook Pro модели А2141**, процессор Intel Core i9 2.4GHz, графика AMD Radeon Pro 5500M 4 ГБ & Intel UHD Graphics 630 1536 МБ, память 64 ГБ 2667 MHz DDR4, c установленной операционной системой Mac OS 15.1.1 (24B91), сборка образов осуществлялась на операционной системе **Ubuntu 20.04, установленной в качестве виртуальной машины VMware Fusion Player Version 13.5.0**;
  - **MacBook Pro модели А2251**, процессор Intel Core i5 2GHz, графика Intel Iris Plus Graphics 1536 МБ, память 16 ГБ 3733 MHz LPDDR4X, c установленной операционной системой Mac OS 15.1.1 (24B91), сборка образов осуществлялась с помощью **Docker Desktop версии 4.34.2**.

Образы собирались на каждом из компьютеров при равных условиях из вышеприведенных Dockerfile, находящихся в одинаковых по структуре и наполнению каталогах.
  - для сборки образа на Alpine linux использовалась команда: 
```shell
docker build -t alpine_ascii_art .
```
  - для сборки образа на Ubuntu использовалась команда: 
```shell
docker build -t ubuntu_ascii_art .
```
В результате сборки зафиксированы следующие параметры, которые для наглядности сведены в таблицу ниже:

| Наименование компьютера | Время сборки образа Alpine | Время сборки образа Ubuntu | Размер образа Alpine | Размер образа Ubuntu |
| :---:                   | :---:                      | :---:                      | :---:                | :---:                |   
| MacBook Pro А1286       | 2 минуты 55 секунд         | 1 минута 17 секунд         | 443 Мб               | 433 Мб               |
| MacBook Pro А2141       | 43 минуты 23 секунды       | 27 минут 44 секунды        | 443 Мб               | 433 Мб               |
| MacBook Pro А2251       | 3 минуты 37 секунд         | 2 минуты 43 секунды        | 443 Мб               | 433 Мб               |

 
### 2. Тестирование Python-приложения в Docker-контейнере
В соответствии с заданием данной практической работы было призведено тестирование Python-приложения в Docker-контейнерах, запущенных из собранных образов, чем получены следующие результаты:
- для запуска контейнера из образа на Alpine linux использовалась команда:
```shell
  docker run -it alpine_ascii_art
```
результат работы приложения в контейнере приведен на иллюстрации ниже
![Снимок экрана 2024-12-04 в 21 17 00](https://github.com/user-attachments/assets/2030a379-bee9-412c-9c6a-527759b9c20b)

- для запуска контейнера из образа на Ubuntu использовалась команда:
```shell
  docker run -it ubuntu_ascii_art
```
результат работы приложения в контейнере приведен на иллюстрации ниже
![Снимок экрана 2024-12-04 в 21 22 59](https://github.com/user-attachments/assets/a8584f81-a97e-40a1-bc28-021d15a44f07)

### 3. Публикация результатов проделанной работы

Для удобства ознакомления с выполненной работой и проверки полученных результатов, каталоги, из которых были собраны вышеупомянутые Docker-образы, помещены в два самораспаковывающихся архива, созданных с помощью утилиты `makeself`, и поименованы как: `alpine_art.run` и `ubuntu_art.run`, соответственно. После чего, полученные файлы были помещены в репозиторий `skill-docker`. Подробнее об использовании утилиты `makeself` и создании самораспаковывающихся архивов можно прочитать [на странице Wiki данного репозитория](https://github.com/al-sapsan/skill-docker/wiki/9.-Cамораспаковывающийся-архив).

Собранные образы были опубликованы в GitHub Container Registry и прикреплены к репозиторию `skill-docker`. Подробнее с процессом публикации и используемыми командами можно ознакомиться [на странице Wiki данного репозитория](https://github.com/al-sapsan/skill-docker/wiki/4.-Интеграция-с-Docker).

### 4. Анализ полученных параметров и выявленных результатов

Анализ проведенной работы и полученных результатов является основанием для выводов о том, что:
1. **Работу с Docker желательно осуществлять на компьютере с операционной системой Linux**
   
Понятно, что здесь нет ничего удивительного и это подтверждает общеизвестный факт. Но данные выводы были получены экспериментальным путем и исходят из того факта, что лучшее время сборки было показано на относительно маломощном ноутбуке MacBook Pro модели А1286, но с предустановленной операционной системой Ubuntu 20.04. Использование Docker Desktop практически в два раза замедлило процесс сборки образа. Ну, а сборка на гостевой операционной системе (хотя и на мощном компьютере) - является наиболее плохой идеей из всех возможных и может быть приемлема только для неторопливых людей с огромным багажом свободного времени.

2. **Использование Alpine linux при сборке Python-проектов не дает весомых преимуществ в размерах образа, но однозначно замедляет процесс сборки**
   
Да, образ на Alpine linux при всех сборках был на 10 Мб меньше. Но имеет ли это значение, если размеры образов более 400 Мб? Думаю, что нет. А вот время сборки на каждом образе у Alpine linux было больше. Следовательно, сборка на Alpine опять нас отсылает к вышеупомянутым людям.

3. **Используйте Alpine для простых задач, а для более сложных - Debian (Ubuntu)**
   
Резюмируя вышесказанное, сборки на Alpine дают весомые преимущества в скорости и размере образов на задачах, не требующих значительного количества зависимостей. Чем проще задача - тем более подходит Alpine. Но в тех случаях, когда сборка осуществляется для сложного проекта с многочисленными зависимостями, видимо, следует использовать Debian или Ubuntu. Тут-то как раз и проявляется их преимущества в стабильности, обновляемости и обширности репозитория.
___
## Работа с Docker Compose.

### 1. Общее описание выполненных действий
Использование Docker Compose для одноконтейнерных сборок, как правильно было замечено в задании данной практической работы, может быть логично обосновано только учебными целями. Таким образом, в данном случае описание можно ограничить моим уверением, что всё работает и наличием комментариев :-)

### 2. Docker-compose.yml для Alpine-образа
```dockerfile
services:       # Определяем сервисы
  ascii-art:         # Название сервиса (можно выбрать любое)
    image: alpine_ascii_art  # Указываем образ, из которого будет создан контейнер
```

### 3. Docker-compose.yml для Ubuntu-образа
```dockerfile
services:       # Определяем сервисы
  ascii-art:         # Название сервиса (можно выбрать любое)
    image: ubuntu_ascii_art  # Указываем образ, из которого будет создан контейнер
```
Подробнее с `docker-compose.yml` можно ознакомиться [на странице Wiki данного репозитория](https://github.com/al-sapsan/skill-docker/wiki/Docker%E2%80%90compose.yml).
